C51 COMPILER V9.60.7.0   UART                                                              04/20/2024 22:57:25 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: D:\Program\MDK51_32\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\UART.lst) OBJECT(.\Objects\UART.obj)

line level    source

   1          #include <STC89C5xRC.H>
   2          
   3          //void UART_Init() //4800bps@11.0592MHz
   4          //{
   5          //      PCON |= 0x80;           //使能波特率倍速位SMOD
   6          //      SCON = 0x40;            //8位数据,可变波特率
   7          
   8          //      TMOD &= 0x0F;           //设置定时器模式
   9          //      TMOD |= 0x20;           //设置定时器模式
  10          
  11          //      TL1 = 0xF4;                     //设置定时初始值
  12          //      TH1 = 0xF4;                     //设置定时重载值
  13          //      ET1 = 0;                        //禁止定时器中断
  14          //      TR1 = 1;                        //定时器1开始计时
  15          //}
  16          
  17          /**
  18            * @brief 串口初始化，4800bps@11.0592MHz
  19            * @param  无
  20            * @retval 无
  21            */
  22          void UART_Init()
  23          {
  24   1          // 1、串行口控制寄存器SCON（Serial Control）和PCON（Power Control）
  25   1          
  26   1          // 1.1、PCON：电源控制寄存器 （不可位寻址）
  27   1          //      B7     B6     B5  B4     B3    B2    B1   B0
  28   1          //   |========================||======================|
  29   1          //   | SMOD | SMOD0 | - | POF || GF1 | GF0 | PD | IDL |
  30   1          //   |  1   |   0   | 0 |  0  ||  0  |  0  | 0  |  0  |
  31   1          //   |========================||======================|
  32   1          // SMOD:    波特率选择位。
  33   1          //      SMOD=1，则使串行通信方式1、2、3的波特率加倍
  34   1          //      SMOD=0，则各工作方式的波特率加倍
  35   1          // SMOD0：  帧错误检测有效控制位
  36   1          //      SMOD0=1，SCON寄存器中的SMO/FE位用于FE(帧错误检测）功能；
  37   1          //      SMOD0=0，SCON寄存器中的SMO/FE位用于SMO功能，和SM1一起指定串行口的工作
             -式
  38   1              PCON |= 0x80;           //使能波特率倍速位SMOD
  39   1          
  40   1          // 1.2、SCON：串行控制寄存器 （可位寻址）
  41   1          //       B7     B6    B5    B4     B3    B2    B1   B0
  42   1          //   |==========================||=====================|
  43   1          //   | SM0/FE | SM1 | SM2 | REN || TB8 | RB8 | TI | RI |
  44   1          //   |    0   |  1  |  0  |  0  ||  0  |  0  | 0  | 0  |
  45   1          //   |==========================||=====================|
  46   1          //    SM0   SM1 工作方式  功能说明                      波特率 10
  47   1          //    0     0   方式0     同步移位串行方式：移位寄存器  波特率是SYSclk/12,
  48   1          //    0     1   方式1     8位UART,波特率可变            (2^SMOD/32)×(定时器1的溢出率)
  49   1          //    1     0   方式2     9位UART                       (2^SMOD/64)×(SYSclk系统工作时钟频
             -)
  50   1          //    1     1   方式3     9位UART,波特率可变            (2^SMOD/32)×(定时器1的溢出率)
  51   1          // 当单片机工作在12T模式时，定时器1的溢出率= SYSclk/12/(256-TH1);
  52   1          // 当单片机工作在6T模式时， 定时器1的溢出率= SYSclk/ 6/(256-TH1);
C51 COMPILER V9.60.7.0   UART                                                              04/20/2024 22:57:25 PAGE 2   

  53   1          // REN(Receive Enable, 允许/禁止串行接收控制位)
  54   1          // TI(Transmit Interrupt, 发送中断请求标志位)
  55   1          // RI(Receive  Interrupt, 接收中断请求标志位)
  56   1              SCON = 0x40;            //8位数据,可变波特率
  57   1          
  58   1          
  59   1          // 2、设置定时器/计数器工作模式寄存器TMOD
  60   1          //       7     6    5    4      3      2    1    0
  61   1          //   |======================||======================|
  62   1          //   | GATE | C/T | M1 | M0 || GATE | C/T | M1 | M0 |
  63   1          //   |   0  |  0  | 1  | 0  ||  -   |  -  | -  | -  |
  64   1          //   |========定时器1=======||=======定时器0========|
  65   1          //    M1    MO  定时器定时器/计数器1模式选择
  66   1          //    0     0   13位定时器/计数器，兼容8048定时模式，TL1只用低5位参与分频，TH1
             -整个8位全用。
  67   1          //    0     1   16位定时器/计数器，TL1、TH1全用
  68   1          //    1     0   8位自动重装载定时器，当溢出时将TH1存放的值自动重装入TL1.
  69   1          //    1     1   定时器/计数器1此时无效（停止计数）。
  70   1              TMOD &= 0x0F;           //设置定时器模式
  71   1              TMOD |= 0x20;           //设置定时器模式
  72   1          
  73   1          
  74   1          // 3、设置定时器1初始值
  75   1              TL1 = 0xF4;                     //设置定时初始值
  76   1              TH1 = 0xF4;                     //设置定时重载值
  77   1          
  78   1          
  79   1          // 4、中断允许寄存器IE和XICON
  80   1          //     B7   B6  B5    B4    B3    B2    B1    B0
  81   1          //   |===================||=======================|
  82   1          //   | EA | - | ET2 | ES || ET1 | EX1 | ET0 | EX0 |
  83   1          //   |===================||=======================|
  84   1              ET1 = 0;                        //禁止定时器中断
  85   1          
  86   1          
  87   1          // 5、定时器/计数器0/1控制寄存器TCON
  88   1          //      B7   B6    B5    B4     B3    B2    B1    B0
  89   1          //   |=======================||=======================|
  90   1          //   | TF1 | TR1 | TF0 | TR0 || IE1 | IT1 | IE0 | IT0 |
  91   1          //   |=======================||=======================|
  92   1              TR1 = 1;                        //定时器1开始计时
  93   1      }
  94          
  95          /**
  96            * @brief 串口向电脑发送字节数据
  97            * @param  一个字节的Byte数据
  98            * @retval 无
  99            */
 100          void UART_SendByte(unsigned int Byte)
 101          {
 102   1          // 串口数据缓冲器
 103   1          SBUF=Byte;
 104   1          
 105   1          // TI: 串行口1发送中断标志。
 106   1          // 串行口1以方式0发送时，每当发送完8位数据，由硬件置1；若以方式1、方式2
             -或方式3发送时，在发送停止位的开始时置1
 107   1          // TI=1表示串行口1正在向CPU申请中断（发送中断）。
 108   1          // 值得注意的是，CPU响应发送中断请求，转向执行中断服务程序时并不将TI清
             -，TI必须由用户在中断服务程序中清零。
 109   1          while(TI==0);
 110   1          TI=0;
 111   1      }
C51 COMPILER V9.60.7.0   UART                                                              04/20/2024 22:57:25 PAGE 3   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     31    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
